// Generated by CoffeeScript 1.2.1-pre
(function() {
  var DepsManager, async, fs, logcheck, util;

  util = require('./util');

  fs = require('fs');

  async = require('async');

  logcheck = function logcheck(fn) {
    return function(file, cb) {
      return fn.call(this, file, function(err, res) {
        util.log(err ? "file " + file + " cannot be checked" : res ? "file " + file + " has been changed" : "file " + file + " is the same");
        return cb(err, res);
      });
    };
  };

  DepsManager = (function() {

    DepsManager.name = 'DepsManager';

    function DepsManager(base) {
      this.base = base;
      this.resolving = {};
      this.deplist = {};
      this.files = {};
      this.min_check_time = 500;
    }

    DepsManager.prototype.clear_deps = function clear_deps(file) {
      return this.deplist[file] = {};
    };

    DepsManager.prototype.depends_on = function depends_on(file, dep) {
      util.log("file " + file + " depends on " + dep + "]");
      return this.deplist[file][dep] = true;
    };

    DepsManager.prototype.resolves_to = function resolves_to(file, path) {
      var _this = this;
      if (path == null) {
        util.log("file " + file + " is not resolved");
        delete this.resolving[file];
        return;
      }
      util.log("file " + file + " is resolved into " + path);
      this.resolving[file] = path;
      return fs.stat(path, function(err, res) {
        if (err) return;
        return _this.files[path] = {
          checked: Date.now(),
          mtime: Number(res.mtime)
        };
      });
    };

    DepsManager.prototype._checkFile = function _checkFile(file, cb) {
      var path,
        _this = this;
      if (this.resolving[file] == null) return cb(null, false);
      path = this.resolving[file];
      if (this.files[path] == null) return cb(null, false);
      return fs.stat(path, function(err, res) {
        var newtime;
        if (err) return cb(err);
        newtime = Number(res.mtime);
        return cb(null, newtime !== _this.files[path].mtime);
      });
    };

    DepsManager.prototype._checkDeps = function _checkDeps(file, cb) {
      var dep, funcs,
        _this = this;
      funcs = [];
      if (this.deplist[file] != null) {
        for (dep in this.deplist[file]) {
          funcs.push(this.check.bind(this, dep));
        }
      }
      return async.parallel(funcs, function(err, res) {
        var i;
        if (err) return cb(err);
        return cb(null, !!((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = res.length; _i < _len; _i++) {
            i = res[_i];
            if (!!i) _results.push(1);
          }
          return _results;
        })()).length);
      });
    };

    DepsManager.prototype.check = logcheck(function(file, cb) {
      var _this = this;
      return async.parallel([this._checkFile.bind(this, file), this._checkDeps.bind(this, file)], function(err, res) {
        if (err) return cb(err);
        return cb(null, res[0] || res[1]);
      });
    });

    return DepsManager;

  })();

  /*
  		return cb(null, false) unless @resolving[file]?
  		path = @resolving[file]
  		return cb(null, false) unless @files[path]?
  		fs.stat(path, (err, res) =>
  			return cb(err) if err
  			newtime = Number(res.mtime)
  			if newtime != @files[path].mtime
  				return cb(null, true)
  
  			funcs = []
  			if @deplist[path]?
  				for dep of @deplist[path]
  					funcs.push @check.bind(@, dep)
  			async.parallel(funcs, (err, res) =>
  				return cb(err) if err
  				# if one of array is true return true, false otherwise
  				return cb(null, !!(1 for i in res when !!i).length)
  			)
  		)
  */


  module.exports = DepsManager;

}).call(this);
