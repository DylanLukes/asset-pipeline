// Generated by CoffeeScript 1.2.1-pre
(function() {
  var Callback, Monad, Path, Wrap, async, crypto, escape_chars, fs, monads, util;

  fs = require('fs');

  async = require('async');

  Path = require('path');

  crypto = require('crypto');

  util = require('./util');

  escape_chars = ['\\', '&', '\'', '"', '<', '>'];

  monads = {};

  Monad = function Monad(fn) {
    this.fn = fn;
    this.id = Math.round(Math.random() * 1e16);
    monads[this.id] = this;
    return this;
  };

  Monad.prototype.toString = function toString() {
    return "[Monad " + this.id + "," + (escape_chars.join(',')) + "]";
  };

  Monad.prototype.unWrap = function unWrap(cb) {
    var _this = this;
    return this.fn(function(err, res) {
      if (err) return cb(err);
      return cb(null, _this._doReplace(res));
    });
  };

  Monad.prototype._doReplace = function _doReplace() {};

  Monad.prototype._setReplace = function _setReplace(str) {
    this._doReplace = function _doReplace(code) {
      var idx, orig, repl, _i, _len, _ref;
      _ref = str.split(',');
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        repl = _ref[idx];
        if (orig = escape_chars[idx]) code = code.split(orig).join(repl);
      }
      return code;
    };
    return this;
  };

  Callback = function Callback() {
    this.callbacks = [];
    return this;
  };

  Callback.prototype.set = function set(args) {
    var cb, _i, _len, _ref;
    this.args = args;
    _ref = this.callbacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cb = _ref[_i];
      cb.apply(null, this.args);
    }
    return this.callbacks = [];
  };

  Callback.prototype.func = function func() {
    var _this = this;
    return function(cb) {
      if (_this.args != null) {
        return cb.apply(null, _this.args);
      } else {
        return _this.callbacks.push(cb);
      }
    };
  };

  Wrap = function Wrap(fn) {
    return function() {
      return new Monad(fn.apply(this, arguments));
    };
  };

  module.exports.call = function call(code, maincb) {
    var fns;
    fns = code.match(/\[Monad [^\]]+\]/g) || [];
    fns = fns.map(function(fn) {
      var m;
      m = fn.match(/\[Monad (\d{2,16}),([^\]]+)\]/);
      if (!((m != null) && (monads[m[1]] != null))) return null;
      return function(cb) {
        return monads[m[1]]._setReplace(m[2]).unWrap(function(err, res) {
          if (err) return cb(err);
          code = code.replace(m[0], res.replace(/\$/g, '$$$$'));
          return cb(err);
        });
      };
    }).filter(function(fn) {
      return fn;
    });
    return async.parallel(fns, function(err) {
      return maincb(err, code);
    });
  };

  module.exports.prepare = function prepare(gopts) {
    var Inlines, compile_file, filename, get_digest, get_file, pipeline;
    pipeline = gopts.pipeline;
    filename = pipeline.path_to_req(gopts.filename);
    Inlines = {};
    get_file = function get_file(file, cb) {
      file = Path.resolve(Path.dirname(filename), file);
      return pipeline.compile_file(file, function(err) {
        if (err) return cb(err);
        return fs.readFile(pipeline.req_to_cache(file), function(err) {
          if (!err) pipeline.depmgr.depends_on(filename, file);
          return cb.apply(null, arguments);
        });
      });
    };
    compile_file = function compile_file(file, cb) {
      file = Path.resolve(Path.dirname(filename), file);
      return pipeline.compile_file(file, function(err, rec) {
        if (err) return cb(err);
        pipeline.depmgr.depends_on(filename, file);
        return cb(err, pipeline.req_to_cache(file), rec);
      });
    };
    get_digest = function get_digest(file, cb) {
      if (pipeline._digest_cache == null) pipeline._digest_cache = {};
      return compile_file(file, function(err, _, wasrecompiled) {
        if (err) return cb(err);
        if (!wasrecompiled && (pipeline._digest_cache[file] != null)) {
          return cb(null, pipeline._digest_cache[file]);
        }
        return fs.readFile(pipeline.req_to_cache(file), function(err, data) {
          var md5, res;
          if (err) return cb(err);
          md5 = crypto.createHash('md5');
          res = md5.update(data).digest('base64');
          res = res.replace(/[^A-Za-z0-9]/g, '').substr(0, 8);
          pipeline._digest_cache[file] = res;
          return cb(null, res);
        });
      });
    };
    Inlines.asset_include = Wrap(function(file, options) {
      var callback;
      if (options == null) options = {};
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_file(file, function(err) {
        var results;
        results = arguments;
        if (!err) {
          results[1] = results[1].toString('utf8');
          if (options.jsescape) {
            results[1] = results[1].replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/'/g, '\\\'').replace(/"/g, '\\\"');
          }
        }
        return callback.set(results);
      });
      return callback.func();
    });
    Inlines.asset_include_dir = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_include_path = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_dir = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_path = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_depend_on = Wrap(function(file) {
      var callback;
      callback = new Callback();
      pipeline.compile_file(file, function(err) {
        if (!err) pipeline.depmgr.depends_on(filename, file);
        return callback.set(arguments);
      });
      return callback.func();
    });
    Inlines.asset_digest = Wrap(function(file, options) {
      var callback;
      if (options == null) options = {};
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_digest(file, function(err, digest) {
        if (err) return callback.set(arguments);
        return callback.set([null, digest]);
      });
      return callback.func();
    });
    Inlines.asset_size = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_mtime = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_ctime = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_uri = Wrap(function(file, options) {
      var callback;
      if (options == null) options = {};
      callback = new Callback();
      file = Path.resolve(Path.dirname(filename), file);
      get_digest(file, function(err, digest) {
        var base, ext, result, _ref;
        if (err) return callback.set(arguments);
        base = ((_ref = Path.basename(file).match(/^[0-9A-Za-z]{1,5}/)) != null ? _ref : [''])[0];
        if (base.length >= 5) base = base.substr(0, 3);
        ext = Path.extname(file);
        result = Path.join(Path.dirname(file), "" + base + "-" + digest + ext);
        return pipeline.register(file, result, function(err) {
          if (err) return callback.set([err]);
          return callback.set([null, result]);
        });
      });
      return callback.func();
    });
    Inlines.asset_echo = Wrap(function(msg) {
      return function(cb) {
        return cb(null, msg);
      };
    });
    return Inlines;
  };

  /*
  Debug = (name, fn) ->
  	(args...) ->
  		console.log("function #{name} called, args=[#{args.join(',')}]")
  		fn.call(@, args...)
  		console.log("function #{name} finished")
  
  somefunction = Debug 'somefunction', (x) ->
  	otherfunction(x+1)
  
  otherfunction = Debug 'otherfunction', (x) ->
  	x+2
  
  somefunction(1)
  */


}).call(this);
