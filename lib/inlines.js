// Generated by CoffeeScript 1.2.1-pre
(function() {
  var Monad, Path, Wrap, async, escape_chars, fs, monads;

  fs = require('fs');

  async = require('async');

  Path = require('path');

  escape_chars = ['\\', '&', '\'', '"', '<', '>'];

  monads = {};

  Monad = function Monad(fn) {
    this.fn = fn;
    this.id = Math.round(Math.random() * 1e16);
    monads[this.id] = this;
    return this;
  };

  Monad.prototype.toString = function toString() {
    return "[Monad " + this.id + "," + (escape_chars.join(',')) + "]";
  };

  Monad.prototype.unWrap = function unWrap(cb) {
    var _this = this;
    return this.fn(function(err, res) {
      if (err) return cb(err);
      return cb(null, _this._doReplace(res));
    });
  };

  Monad.prototype._doReplace = function _doReplace() {};

  Monad.prototype._setReplace = function _setReplace(str) {
    this._doReplace = function _doReplace(code) {
      var idx, orig, repl, _i, _len, _ref;
      _ref = str.split(',');
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        repl = _ref[idx];
        if (orig = escape_chars[idx]) code = code.split(orig).join(repl);
      }
      return code;
    };
    return this;
  };

  Wrap = function Wrap(fn) {
    return function() {
      return new Monad(fn.apply(this, arguments));
    };
  };

  module.exports.call = function call(code, maincb) {
    var fns;
    fns = code.match(/\[Monad [^\]]+\]/g) || [];
    fns = fns.map(function(fn) {
      var m;
      m = fn.match(/\[Monad (\d{2,16}),([^\]]+)\]/);
      if (!((m != null) && (monads[m[1]] != null))) return null;
      return function(cb) {
        return monads[m[1]]._setReplace(m[2]).unWrap(function(err, res) {
          code = code.replace(m[0], res);
          return cb(err);
        });
      };
    }).filter(function(fn) {
      return fn;
    });
    return async.parallel(fns, function(err) {
      return maincb(err, code);
    });
  };

  module.exports.prepare = function prepare(gopts) {
    var Inlines;
    Inlines = {};
    Inlines.asset_include = Wrap(function(file, options) {
      var callback, filename, results;
      if (options == null) options = {};
      filename = gopts.pipeline.path_to_req(gopts.filename);
      results = null;
      callback = null;
      file = Path.resolve(Path.dirname(filename), file);
      gopts.pipeline.compile_file(file, function(err) {
        return fs.readFile(gopts.pipeline.req_to_cache(file), 'utf8', function(err) {
          if (!err) gopts.pipeline.depmgr.depends_on(filename, file);
          results = arguments;
          if (!err) {
            if (options.jsescape) {
              results[1] = results[1].replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/'/g, '\\\'').replace(/"/g, '\\\"');
            }
          }
          if (callback != null) return callback.apply(null, results);
        });
      });
      return function(cb) {
        callback = cb;
        if (results != null) return callback.apply(null, results);
      };
    });
    Inlines.asset_include_dir = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_include_path = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_dir = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_require_path = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_depend_on = Wrap(function(file) {
      var callback, filename, results;
      filename = gopts.pipeline.path_to_req(gopts.filename);
      results = null;
      callback = null;
      gopts.pipeline.compile_file(file, function(err) {
        if (!err) gopts.pipeline.depmgr.depends_on(filename, file);
        results = arguments;
        if (callback != null) return callback.apply(null, results);
      });
      return function(cb) {
        callback = cb;
        if (results != null) return callback.apply(null, results);
      };
    });
    Inlines.asset_digest = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_md5 = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_size = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_mtime = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_ctime = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_atime = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_uri = Wrap(function(file, options) {
      if (options == null) options = {};
      return function(cb) {
        return cb('not supported yet');
      };
    });
    Inlines.asset_echo = Wrap(function(msg) {
      return function(cb) {
        return cb(null, msg);
      };
    });
    return Inlines;
  };

  /*
  Debug = (name, fn) ->
  	(args...) ->
  		console.log("function #{name} called, args=[#{args.join(',')}]")
  		fn.call(@, args...)
  		console.log("function #{name} finished")
  
  somefunction = Debug 'somefunction', (x) ->
  	otherfunction(x+1)
  
  otherfunction = Debug 'otherfunction', (x) ->
  	x+2
  
  somefunction(1)
  */


}).call(this);
