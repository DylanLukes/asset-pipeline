// Generated by CoffeeScript 1.2.1-pre
(function() {
  var Connect, DepMgr, MakePath, Path, Pipeline, URL, async, fs, util,
    __slice = [].slice;

  Path = require('path');

  Connect = require('connect');

  URL = require('url');

  fs = require('fs');

  async = require('async');

  DepMgr = require('./depmgr');

  MakePath = require('./makepath');

  util = require('./util');

  Pipeline = (function() {

    Pipeline.name = 'Pipeline';

    function Pipeline(options, plugins) {
      var file, oldrender, _base, _base2, _base3, _base4, _i, _len, _ref, _ref2, _ref3,
        _this = this;
      this.options = options;
      this.plugins = plugins;
      this.files = {};
      this.compile_queue = {};
      if ((_base = this.options).assets == null) _base.assets = './assets';
      this.options.assets = Path.normalize(this.options.assets);
      if ((_base2 = this.options).cache == null) _base2.cache = './cache';
      this.options.cache = Path.normalize(this.options.cache);
      if ((_base3 = this.options).cwd == null) _base3.cwd = this.options.assets;
      this.tempDir = Path.join(this.options.cache, 'tmp');
      this.staticDir = Path.join(this.options.cache, 'static');
      try {
        fs.mkdirSync(this.tempDir);
      } catch (_error) {}
      try {
        fs.mkdirSync(this.staticDir);
      } catch (_error) {}
      if (this.options.debug != null) util.do_log(this.options.debug);
      if ((_base4 = this.options).extensions == null) {
        _base4.extensions = ['.js', '.css'];
      }
      this.options.extensions = this.options.extensions.map(function(x) {
        if (x[0] === '.') {
          return x;
        } else {
          return '.' + x;
        }
      });
      this.depmgr = new DepMgr(this.options.assets);
      this.depmgr.min_check_time = (_ref = this.options.min_check_time) != null ? _ref : 1000;
      this.servers = {
        normal: Connect["static"](this.staticDir),
        caching: Connect["static"](this.staticDir, {
          maxAge: 365 * 24 * 60 * 60
        })
      };
      _ref3 = (_ref2 = this.options.files) != null ? _ref2 : [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        file = _ref3[_i];
        this.files[Path.join('/', file)] = {
          serve: true
        };
      }
      if ((this.options.server != null) && (this.options.server.engine != null)) {
        this.options.server.engine('pipeline', this.render_view.bind(this));
        this.options.server.set('view engine', 'pipeline');
        oldrender = this.options.server.render;
        if (oldrender != null) {
          this.options.server.render = function render(view, options, fn) {
            if ('function' === typeof options) {
              fn = options;
              options = {};
            }
            options.view_name = view;
            return oldrender.call(_this.options.server, '/', options, fn);
          };
        }
      } else if (this.options.server != null) {
        process.emit('error', new Error("You are using old version of Express. I would recommend to upgrade it to express 3. You could use 2nd, but some features like view rendering will not work in this library (assets-pipeline)."));
      }
    }

    Pipeline.prototype.can_serve_file = function can_serve_file(file) {
      var ext, _i, _len, _ref, _ref2;
      if ((_ref = this.files[file]) != null ? _ref.serve : void 0) return true;
      _ref2 = this.options.extensions;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        ext = _ref2[_i];
        if (Path.extname(file) === ext) return true;
      }
      return false;
    };

    Pipeline.prototype.middleware = function middleware() {
      var _this = this;
      return function(req, res, _next) {
        var file, next, path, server, url, _ref;
        next = function next() {
          return _next.apply(null, arguments);
        };
        url = URL.parse(req.url);
        path = decodeURIComponent(url.pathname);
        file = Path.join('/', path);
        if (_this.can_serve_file(file)) {
          util.log('trying to serve ' + file);
          server = ((_ref = _this.files[file]) != null ? _ref.cache : void 0) ? _this.servers.caching : _this.servers.normal;
          return _this.serve_file(req, res, file, server, next);
        } else {
          return next();
        }
      };
    };

    Pipeline.prototype.serve_file = function serve_file(req, res, file, server, next, safe) {
      var file_defined, safeNext, _base, _ref,
        _this = this;
      if (safe == null) safe = 1;
      safeNext = next;
      if (safe) {
        safeNext = function safeNext(err) {
          if (err) return next(err);
          _this.files[file].compiled = false;
          return _this.serve_file(req, res, file, server, next, 0);
        };
      }
      if (((_ref = this.files[file]) != null ? _ref.compiled : void 0) && this.files[file].cache) {
        return server(req, res, safeNext);
      } else {
        file_defined = this.files[file] != null;
        if ((_base = this.files)[file] == null) _base[file] = {};
        this.files[file].serve = true;
        return this.compile_file(file, {}, function(err) {
          if (err) {
            if (!file_defined) delete _this.files[file];
            if ((err != null ? err.code : void 0) === 'asset-pipeline/filenotfound') {
              return next();
            } else {
              return next(err);
            }
          }
          console.log('publishing', file, _this.files[file]);
          return _this.publish_file(file, function(err) {
            if (err) return next(err);
            return server(req, res, safeNext);
          });
        });
      }
    };

    Pipeline.prototype.render_view = function render_view(_, options, cb) {
      var file, func,
        _this = this;
      file = Path.join('/', options.view_name);
      func = function func(retry) {
        var _base;
        if ((_base = _this.files)[file] == null) _base[file] = {};
        return _this.compile_file(file, options, function(err) {
          if (err) {
            if (retry) {
              _this.files[file].compiled = false;
              return func(0);
            } else {
              return cb(err);
            }
          } else {
            return fs.readFile(_this.req_to_cache(file), cb);
          }
        });
      };
      return func(1);
    };

    Pipeline.prototype.check_if_changed = function check_if_changed(file, cb) {
      var _ref,
        _this = this;
      if (!((_ref = this.files[file]) != null ? _ref.compiled : void 0)) {
        return cb();
      } else {
        return this.depmgr.check(file, function(err, changed) {
          if (err) return cb(err);
          if (changed) _this.files[file].compiled = false;
          return cb();
        });
      }
    };

    Pipeline.prototype.compile_file = function compile_file(file, options, cb) {
      var _this = this;
      return this.check_if_changed(file, function(err) {
        var finish, run_callbacks, _ref;
        if (err) return cb(err);
        if ((_ref = _this.files[file]) != null ? _ref.compiled : void 0) {
          return cb();
        }
        util.log("compiling " + file);
        if (_this.compile_queue[file] != null) {
          _this.compile_queue[file].push(cb);
          return;
        }
        _this.compile_queue[file] = [cb];
        run_callbacks = function run_callbacks() {
          var args, old_queue;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          old_queue = _this.compile_queue[file];
          delete _this.compile_queue[file];
          args.unshift(null);
          return old_queue.map(function(f) {
            return f.apply(f, args);
          });
        };
        finish = function finish(err) {
          var _base;
          if (!err) {
            if ((_base = _this.files)[file] == null) _base[file] = {};
            _this.files[file].compiled = true;
          }
          return run_callbacks(err);
        };
        return MakePath.find(_this.options.cwd, file, function(err, found) {
          if (err) {
            _this.depmgr.resolves_to(file, null);
            return run_callbacks(err);
          }
          _this.depmgr.resolves_to(file, found.path);
          return _this.send_to_pipeline(file, options, found.path, found.extlist, function(err) {
            var _ref2;
            if (err) return run_callbacks(err);
            if ((_ref2 = _this.files[file]) != null ? _ref2.serve : void 0) {
              return util.link_file(_this.req_to_cache(file), _this.req_to_static(file), function(err) {
                if (!err) _this.files[file].published = true;
                return finish(err);
              });
            } else {
              return finish(err);
            }
          });
        });
      });
    };

    Pipeline.prototype.publish_file = function publish_file(file, cb) {
      var _this = this;
      if ((this.files[file] != null) && this.files[file].serve && !this.files[file].published) {
        return util.link_file(this.req_to_cache(file), this.req_to_static(file), function(err) {
          _this.files[file].published = true;
          return cb();
        });
      } else {
        return cb();
      }
    };

    Pipeline.prototype.actual_pipeline = function actual_pipeline(data, pipes, filename, attrs, cb) {
      var newfile, oldfile, pipe,
        _this = this;
      if (pipes.length === 0) return cb(null, data);
      data = data.toString('utf8');
      pipe = pipes.shift();
      if (pipe.ext === '') {
        return this.actual_pipeline(data, pipes, pipe.file, attrs, cb);
      }
      if (!this.plugins[pipe.ext].compile) {
        return cb(new Error('compiler not found'));
      }
      attrs.filename = pipe.file;
      oldfile = this.path_to_req(filename);
      newfile = this.path_to_req(pipe.file);
      this.depmgr.clear_deps(newfile);
      this.depmgr.depends_on(newfile, oldfile);
      attrs.filename = pipe.file;
      return this.plugins[pipe.ext].compile(data, attrs, function(err, result) {
        if (err) return cb(err);
        return _this.actual_pipeline(result, pipes, pipe.file, attrs, cb);
      });
    };

    Pipeline.prototype.send_to_pipeline = function send_to_pipeline(reqfile, options, file, plugins, cb) {
      var dest,
        _this = this;
      dest = Path.join(this.tempDir, reqfile);
      this.depmgr.clear_deps(this.path_to_req(file));
      return fs.readFile(file, function(err, data) {
        if (err) return cb(err);
        return _this.actual_pipeline(data, plugins, file, {
          pipeline: _this,
          render: options
        }, function(err, data) {
          if (err) return cb(err);
          return util.write_file(dest, data, cb);
        });
      });
    };

    Pipeline.prototype.register = function register(orig_name, static_name, cb) {
      var _this = this;
      return util.link_file(this.req_to_cache(orig_name), this.req_to_static(static_name), function(err, res) {
        if (err) return cb(err);
        _this.files[static_name] = {
          cache: true,
          serve: true,
          compiled: true,
          published: true
        };
        return cb();
      });
    };

    Pipeline.prototype.path_to_req = function path_to_req(path) {
      return Path.join('/', Path.relative(this.options.assets, path));
    };

    Pipeline.prototype.path_to_cache = function path_to_cache(path) {
      return Path.join(this.tempDir, this.path_to_req(path));
    };

    Pipeline.prototype.req_to_cache = function req_to_cache(path) {
      return Path.join(this.tempDir, path);
    };

    Pipeline.prototype.req_to_static = function req_to_static(path) {
      return Path.join(this.staticDir, path);
    };

    return Pipeline;

  })();

  module.exports = Pipeline;

}).call(this);
